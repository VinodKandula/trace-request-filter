package com.shedhack.trace.request.filter;


import com.shedhack.trace.request.api.constant.HttpHeaderKeysEnum;
import com.shedhack.trace.request.api.constant.Status;
import com.shedhack.trace.request.api.model.DefaultRequestModel;
import com.shedhack.trace.request.api.model.RequestModel;
import com.shedhack.trace.request.api.service.TraceRequestService;
import com.shedhack.trace.request.api.threadlocal.RequestThreadLocalHelper;
import com.shedhack.trace.request.filter.utility.HttpUtilities;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.io.IOException;
import java.util.*;

/**
 * <pre>
 *  In distributed systems it is difficult to trace the execution paths of multiple services.
 *  This filter will set several header properties and will also provide
 *  an easy to access ThreadLocal {@link com.shedhack.trace.request.api.threadlocal.RequestThreadLocalHelper} utility class.
 *
 *  The properties are:
 *
 *  1. 'request-id': the servlet filter attempts to create a 'request-id' header property
 *      if this hasn't already been set. The request-id is unique for the given request and can be used
 *      for many purposes such as building metrics (user request count), auditing,
 *      logging, exception handling etc. The Id is based on {@link UUID} which guarantees an
 *      incredibly low chance of a collision. Thus the Id can be used to search for particular requests.
 *
 *  2. 'group-id': in the world of soa and micro-services, services are not isolated. Services almost
 *      always call other distributed services. Let's take an example, a user submits a request on his
 *      iphone app. The app calls a backend service which itself calls multiple services. In order to see
 *      which services were called you could use a 'group-id'. The group Id is a unique parent/wrapper Id.
 *      Searching for just this in your centralised logs would show all service calls. This is not to be
 *      confused with the request Id which is the Id for a single service call.
 *
 *  3. 'caller-id': as mentioned above services interact with other services. One service is the client
 *      whilst the other is provider (server). The interaction between the two services can logged
 *      using the use of a 'caller-id'. When service A calls service B, the caller-id that I'm
 *      alluding to is the request-id that A originally had set in its header. The HTTP request
 *      will therefore contain the caller-id and the group-id. The request-id would be generated by this
 *      filter or by a web server.
 *
 *  4. 'application-id': a key/name/id that can identify the application/service being called.
 *
 *     To enable easy access to the request Id value it gets stored on as a ThreadLocal variable.
 *     Please note that the ThreadLocal gets cleaned up in this filter.
 *
 * When constructing this filter you'll need to provide the application name/Id. This
 * is stored in the RequestModel.
 * </pre>
 *
 * @author imamchishty
 */
public class RequestTraceFilter implements Filter {

    /**
     * Default constructor.
     */
    public RequestTraceFilter(String applicationId, TraceRequestService requestService) {
        this.appId = applicationId;
        this.requestService = requestService;
    }

    private final String appId;

    private final TraceRequestService requestService;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

        try {

            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HeaderWrapper headerWrapper = new HeaderWrapper(httpRequest);

            // ----------
            // Request Id
            // ---------

            String requestId = headerWrapper.getHeader(HttpHeaderKeysEnum.REQUEST_ID.key());

            if (requestId == null) {
                requestId = UUID.randomUUID().toString();
                headerWrapper.addHeader(HttpHeaderKeysEnum.REQUEST_ID.key(), requestId);
            }

            // --------
            // Group Id
            // --------

            String groupId = headerWrapper.getHeader(HttpHeaderKeysEnum.GROUP_ID.key());

            if (groupId == null) {
                groupId = UUID.randomUUID().toString();
                headerWrapper.addHeader(HttpHeaderKeysEnum.GROUP_ID.key(), requestId);
            }

            // Set the thread local for access later.
            RequestModel model = new DefaultRequestModel().builder(appId, requestId, groupId)
                    .withRequestDateTime(new Date())
                    .withCallerId(headerWrapper.getHeader(HttpHeaderKeysEnum.CALLER_ID.key()))
                    .withClientAddress(httpRequest.getRemoteAddr())
                    .withHostAddress(httpRequest.getHeader(HttpHeaderKeysEnum.HOST.key()))
                    .withPath(httpRequest.getRequestURI())
                    .withHttpMethod(httpRequest.getMethod())
                    .withSessionId(httpRequest.getSession().getId())
                    .withHttpHeaders(HttpUtilities.headerNamesValuesAsString(httpRequest))
                    .withStatus(Status.RUNNING).build();

            // Set in the thread local for easy access.
            RequestThreadLocalHelper.set(model);

            System.out.println(new Date() + "> BEFORE FILTER CHAIN");

            // continue down the chain
            chain.doFilter(headerWrapper, response);

            System.out.println(new Date() + "> AFTER FILTER CHAIN " + RequestThreadLocalHelper.get().toString());

        }
        finally {

            // clean up
            RequestThreadLocalHelper.clear();

            System.out.println(new Date() + "> CLEAN TL");

        }
    }

    @Override
    public void destroy() {

    }

    public class HeaderWrapper extends HttpServletRequestWrapper {

        public HeaderWrapper(HttpServletRequest request) {
            super(request);
        }

        private Map<String, String> headerMap = new HashMap<>();

        public void addHeader(String name, String value) {
            headerMap.put(name, value);
        }

        @Override
        public String getHeader(String name) {
            String headerValue = super.getHeader(name);
            if (headerMap.containsKey(name)) {
                headerValue = headerMap.get(name);
            }
            return headerValue;
        }

        @Override
        public Enumeration<String> getHeaderNames() {
            List<String> names = Collections.list(super.getHeaderNames());
            for (String name : headerMap.keySet()) {
                names.add(name);
            }
            return Collections.enumeration(names);
        }

        @Override
        public Enumeration<String> getHeaders(String name) {
            List<String> values = Collections.list(super.getHeaders(name));
            if (headerMap.containsKey(name)) {
                values.add(headerMap.get(name));
            }
            return Collections.enumeration(values);
        }

    }
}
