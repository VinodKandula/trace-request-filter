package com.shedhack.filter.requestid;

import com.shedhack.filter.requestid.helper.RequestHelper;
import com.shedhack.filter.requestid.model.RequestModel;
import org.slf4j.MDC;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.io.IOException;
import java.util.*;

/**
 * <pre>
 *  In distributed systems it is difficult to trace the execution paths of multiple services.
 *  This filter will set several header properties, MDC for logging and will also provide
 *  an easy to access ThreadLocal {@link RequestHelper} utility class.
 *
 *  The three properties are:
 *
 *  1. 'request-id': the servlet filter attempts to create a 'request-id' header property
 *      if this hasn't already been set. The request-id is unique for the given request and can be used
 *      for many purposes such as building metrics (user request count), auditing,
 *      logging, exception handling etc. The Id is based on {@link UUID} which guarantees an
 *      incredibly low chance of a collision. Thus the Id can be used to search for particular requests.
 *
 *  2. 'group-id': in the world of soa and micro-services, services are not isolated. Services almost
 *      always call other distributed services. Let's take an example, a user submits a request on his
 *      iphone app. The app calls a backend service which itself calls multiple services. In order to see
 *      which services were called you could use a 'group-id'. The group Id is a unique parent/wrapper Id.
 *      Searching for just this in your centralised logs would show all service calls. This is not to be
 *      confused with the request Id which is the Id for a single service call.
 *
 *  3. 'caller-id': as mentioned above services interact with other services. One service is the client
 *      whilst the other is provider (server). The interaction between the two services can logged
 *      using the use of a 'caller-id'. When service A calls service B, the caller-id that I'm
 *      alluding to is the request-id that A originally had set in its header. The HTTP request
 *      will therefore contain the caller-id and the group-id. The request-id would be generated by this
 *      filter or by a web server.
 *
 *     To enable easy access to the request Id value it gets stored on as a ThreadLocal variable.
 *     Please note that the MDC and the ThreadLocal gets cleaned up in this filter.
 *
 * </pre>
 *
 * @author imamchishty
 */
public class RequestIdFilter implements Filter {

    /**
     * Default constructor with the HTTP header property for requestId key set to 'request-id'.
     */
    public RequestIdFilter() {

    }

    public static final String REQUEST_ID = "request-id";
    public static final String GROUP_ID = "group-id";
    public static final String CALLER_ID = "caller-id";


    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

        try {
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HeaderWrapper headerWrapper = new HeaderWrapper(httpRequest);

            // ----------
            // Request Id
            // ---------

            String requestId = headerWrapper.getHeader(REQUEST_ID);

            if (requestId == null) {
                requestId = UUID.randomUUID().toString();
                headerWrapper.addHeader(REQUEST_ID, requestId);
            }

            // --------
            // Group Id
            // --------

            String groupId = headerWrapper.getHeader(GROUP_ID);

            if (groupId == null) {
                groupId = UUID.randomUUID().toString();
                headerWrapper.addHeader(GROUP_ID, requestId);
            }

            // Set the thread local for access later.
            RequestHelper.set(new RequestModel(requestId, groupId, headerWrapper.getHeader(CALLER_ID)));

            // Also set MDC for supported loggers:
            MDC.put(GROUP_ID, groupId);
            MDC.put(REQUEST_ID, requestId);
            MDC.put(CALLER_ID, headerWrapper.getHeader(CALLER_ID));

            // continue down the chain
            chain.doFilter(headerWrapper, response);
        }
        finally {

            // clean up
            RequestHelper.clear();
            MDC.clear();
        }
    }

    @Override
    public void destroy() {

    }

    public String getRequestIdKey() {
        return REQUEST_ID;
    }


    public class HeaderWrapper extends HttpServletRequestWrapper {

        public HeaderWrapper(HttpServletRequest request) {
            super(request);
        }

        private Map<String, String> headerMap = new HashMap<>();

        public void addHeader(String name, String value) {
            headerMap.put(name, value);
        }

        @Override
        public String getHeader(String name) {
            String headerValue = super.getHeader(name);
            if (headerMap.containsKey(name)) {
                headerValue = headerMap.get(name);
            }
            return headerValue;
        }

        @Override
        public Enumeration<String> getHeaderNames() {
            List<String> names = Collections.list(super.getHeaderNames());
            for (String name : headerMap.keySet()) {
                names.add(name);
            }
            return Collections.enumeration(names);
        }

        @Override
        public Enumeration<String> getHeaders(String name) {
            List<String> values = Collections.list(super.getHeaders(name));
            if (headerMap.containsKey(name)) {
                values.add(headerMap.get(name));
            }
            return Collections.enumeration(values);
        }

    }
}
